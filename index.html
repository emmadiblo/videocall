<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plateforme d'Appel Vidéo</title>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --primary-hover: #4a49b9;
            --text-color: #333;
            --bg-color: #fff;
            --surface-color: #f5f5f5;
            --border-color: #e0e0e0;
            --error-color: #e53935;
            --success-color: #43a047;
            --info-color: #2196f3;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        .dark {
            --text-color: #f5f5f5;
            --bg-color: #181818;
            --surface-color: #242424;
            --border-color: #404040;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        h1, h2, h3 {
            margin-bottom: 15px;
            color: var(--text-color);
        }

        /* Authentication styles */
        .auth-container {
            max-width: 500px;
            margin: 0 auto;
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        input[type="text"],
        input[type="email"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 16px;
            transition: var(--transition);
        }

        input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(93, 92, 222, 0.2);
        }

        .btn {
            display: inline-block;
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: var(--transition);
            text-align: center;
        }

        .btn:hover {
            background-color: var(--primary-hover);
        }

        .btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .btn-secondary:hover {
            background-color: rgba(93, 92, 222, 0.1);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* User dashboard */
        .user-dashboard {
            display: none;
        }

        .user-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .room-list {
            background-color: var(--surface-color);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }

        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .room-item:last-child {
            border-bottom: none;
        }

        .room-code-small {
            font-family: monospace;
            background-color: var(--bg-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        /* Setup section */
        .setup-section {
            background-color: var(--surface-color);
            border-radius: var(--radius);
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }

        .setup-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        @media (max-width: 600px) {
            .setup-actions {
                flex-direction: column;
            }
        }

        /* Connection info */
        .connection-info {
            display: none;
            background-color: var(--surface-color);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            text-align: center;
        }

        .room-code {
            font-family: monospace;
            font-size: 24px;
            font-weight: bold;
            background-color: var(--bg-color);
            padding: 10px;
            border-radius: var(--radius);
            margin: 20px 0;
            display: inline-block;
            min-width: 150px;
        }

        .connection-status {
            display: none;
            margin-bottom: 20px;
        }

        /* Video container - MODIFIÉ pour supporter plusieurs participants */
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease;
            position: relative;
        }

        .video-container.active {
            height: auto;
            margin-bottom: 20px;
        }

        /* Grille dynamique pour s'adapter au nombre de participants */
        .video-container.participants-1 {
            grid-template-columns: 1fr;
        }
        
        .video-container.participants-2 {
            grid-template-columns: 1fr 1fr;
        }
        
        .video-container.participants-3 {
            grid-template-columns: 1fr 1fr;
        }
        
        .video-container.participants-4 {
            grid-template-columns: 1fr 1fr;
        }
        
        .video-container.participants-5,
        .video-container.participants-6 {
            grid-template-columns: repeat(3, 1fr);
        }
        
        .video-container.participants-7,
        .video-container.participants-8,
        .video-container.participants-9 {
            grid-template-columns: repeat(3, 1fr);
        }

        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr;
            }
        }

        .video-box {
            position: relative;
            background-color: var(--surface-color);
            border-radius: var(--radius);
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        /* Vidéo locale en miniature */
        .local-video-mini {
            position: absolute;
            width: 200px;
            height: 150px;
            bottom: 20px;
            right: 20px;
            border-radius: var(--radius);
            overflow: hidden;
            z-index: 100;
            box-shadow: var(--shadow);
            border: 2px solid var(--primary-color);
            transition: all 0.3s ease;
        }

        .local-video-mini:hover {
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .local-video-mini {
                width: 120px;
                height: 90px;
                bottom: 10px;
                right: 10px;
            }
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 10;
        }

        .waiting-message {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            z-index: 5;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror local video */
        }

        /* Call controls */
        .call-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background-color: var(--surface-color);
            border-radius: var(--radius);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .call-controls.active {
            opacity: 1;
            transform: translateY(0);
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: var(--surface-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: var(--transition);
        }

        .control-btn:hover {
            background-color: var(--primary-color);
            color: white;
        }

        .control-btn.muted, .control-btn.disabled {
            background-color: #e53935;
            color: white;
        }

        .leave-btn {
            background-color: #e53935;
            color: white;
        }

        .leave-btn:hover {
            background-color: #c62828;
        }

        /* Status messages */
        .status-message {
            padding: 10px 15px;
            border-radius: var(--radius);
            margin-bottom: 15px;
            font-weight: 500;
            display: none;
        }

        .status-message.error {
            background-color: rgba(229, 57, 53, 0.1);
            color: #e53935;
            border-left: 4px solid #e53935;
        }

        .status-message.success {
            background-color: rgba(67, 160, 71, 0.1);
            color: #43a047;
            border-left: 4px solid #43a047;
        }

        .status-message.info {
            background-color: rgba(33, 150, 243, 0.1);
            color: #2196f3;
            border-left: 4px solid #2196f3;
        }

        /* Debug panel */
        .debug-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--surface-color);
            border-radius: var(--radius);
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .debug-entry {
            margin-bottom: 5px;
            padding: 3px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Chat section */
        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            background-color: var(--surface-color);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            z-index: 1000;
            display: none;
            flex-direction: column;
            height: 400px;
            transition: all 0.3s ease;
        }

        .chat-container.active {
            display: flex;
        }

        .chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            border-top-left-radius: var(--radius);
            border-top-right-radius: var(--radius);
        }

        .chat-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-message {
            padding: 10px;
            border-radius: var(--radius);
            max-width: 80%;
            word-break: break-word;
        }

        .chat-message.sent {
            align-self: flex-end;
            background-color: var(--primary-color);
            color: white;
        }

        .chat-message.received {
            align-self: flex-start;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
        }

        .message-sender {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--border-color);
        }

        .chat-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius) 0 0 var(--radius);
            font-size: 16px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .chat-send {
            padding: 10px 15px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0 var(--radius) var(--radius) 0;
            cursor: pointer;
        }

        .chat-send:hover {
            background-color: var(--primary-hover);
        }

        .chat-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            box-shadow: var(--shadow);
            z-index: 999;
        }

        .chat-toggle.active {
            display: flex;
        }

        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #e53935;
            color: white;
            font-size: 12px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Share link */
        .share-link-container {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .share-link {
            flex: 1;
            padding: 10px;
            background-color: var(--bg-color);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            font-family: monospace;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Participants list */
        .participants-container {
            margin-top: 20px;
            background-color: var(--surface-color);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: var(--shadow);
        }

        .participants-list {
            list-style-type: none;
            margin-top: 10px;
        }

        .participant-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .participant-item:last-child {
            border-bottom: none;
        }

        .participant-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-weight: bold;
        }

        .participant-name {
            flex: 1;
        }

        .participant-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--success-color);
            margin-left: 10px;
        }

        .participant-status.offline {
            background-color: var(--error-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🎥 VideoCall</h1>
            <button id="themeToggle" class="btn btn-secondary">🌙</button>
        </header>

        <!-- Section d'authentification -->
        <div id="authContainer" class="auth-container">
            <div class="tabs">
                <div class="tab active" data-tab="login">Connexion</div>
                <div class="tab" data-tab="register">Inscription</div>
            </div>
            
            <div id="loginTab" class="tab-content active">
                <h2>Connexion</h2>
                <div id="loginMessage" class="status-message"></div>
                
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" placeholder="Votre email">
                </div>
                
                <div class="form-group">
                    <label for="loginPassword">Mot de passe</label>
                    <input type="password" id="loginPassword" placeholder="Votre mot de passe">
                </div>
                
                <button id="loginBtn" class="btn">Se connecter</button>
            </div>
            
            <div id="registerTab" class="tab-content">
                <h2>Créer un compte</h2>
                <div id="registerMessage" class="status-message"></div>
                
                <div class="form-group">
                    <label for="registerName">Nom</label>
                    <input type="text" id="registerName" placeholder="Votre nom complet">
                </div>
                
                <div class="form-group">
                    <label for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" placeholder="Votre email">
                </div>
                
                <div class="form-group">
                    <label for="registerPassword">Mot de passe</label>
                    <input type="password" id="registerPassword" placeholder="Créez un mot de passe">
                </div>
                
                <div class="form-group">
                    <label for="registerPasswordConfirm">Confirmer le mot de passe</label>
                    <input type="password" id="registerPasswordConfirm" placeholder="Confirmez votre mot de passe">
                </div>
                
                <button id="registerBtn" class="btn">S'inscrire</button>
            </div>
        </div>

        <!-- Tableau de bord utilisateur -->
        <div id="userDashboard" class="user-dashboard">
            <div class="user-info">
                <h2>Bienvenue, <span id="userNameDisplay"></span></h2>
                <button id="logoutBtn" class="btn btn-secondary">Déconnexion</button>
            </div>
            
            <div id="statusMessage" class="status-message"></div>
            
            <!-- Liste des salles récentes -->
            <div id="roomList" class="room-list">
                <h3>Vos salles récentes</h3>
                <div id="roomListItems"></div>
            </div>
            
            <!-- Section de configuration -->
            <div id="setupSection" class="setup-section">
                <h3>Créer ou rejoindre une salle</h3>
                <p>Créez une nouvelle salle ou rejoignez-en une existante en utilisant son code.</p>
                
                <div class="form-group">
                    <label for="roomCode">Code de salle</label>
                    <input type="text" id="roomCode" placeholder="Entrez le code à 6 caractères">
                </div>
                
                <div class="setup-actions">
                    <button id="joinRoomBtn" class="btn">Rejoindre</button>
                    <button id="createRoomBtn" class="btn btn-secondary">Créer une nouvelle salle</button>
                </div>
            </div>
            
            <!-- Informations de connexion -->
            <div id="connectionInfo" class="connection-info">
                <h3>Votre salle est prête !</h3>
                <p>Partagez ce code avec les personnes que vous souhaitez inviter :</p>
                <div class="room-code" id="roomCodeText">------</div>
                <button id="copyCodeBtn" class="btn">📋 Copier</button>
                
                <div class="share-link-container">
                    <div class="share-link" id="shareLink"></div>
                    <button id="copyLinkBtn" class="btn btn-secondary">📋</button>
                </div>
                
                <p>En attente de connexion...</p>
            </div>
            
            <div id="connectionStatus" class="connection-status">
                <div class="loading"></div>
                <p>Établissement de la connexion...</p>
            </div>
            
            <!-- Liste des participants -->
            <div id="participantsContainer" class="participants-container" style="display:none;">
                <h3>Participants (<span id="participantCount">0</span>)</h3>
                <ul id="participantsList" class="participants-list"></ul>
            </div>
            
            <!-- Conteneur vidéo modifié pour support multi-utilisateurs -->
            <div id="videoContainer" class="video-container">
                <!-- Les éléments vidéo seront ajoutés dynamiquement par JavaScript -->
            </div>
            
            <!-- Vidéo locale en miniature -->
            <div id="localVideoMini" class="local-video-mini" style="display:none;">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label">Vous</div>
            </div>
            
            <!-- Contrôles d'appel -->
            <div id="callControls" class="call-controls">
                <button id="muteBtn" class="control-btn" title="Couper le micro">🎤</button>
                <button id="videoBtn" class="control-btn" title="Couper la caméra">📹</button>
                <button id="chatBtn" class="control-btn" title="Chat">💬</button>
                <button id="leaveBtn" class="control-btn leave-btn" title="Quitter l'appel">❌</button>
            </div>
            
            <!-- Chat en temps réel -->
            <div id="chatToggle" class="chat-toggle">
                💬
                <div id="chatNotification" class="notification-badge" style="display:none;">0</div>
            </div>
            
            <div id="chatContainer" class="chat-container">
                <div class="chat-header">
                    <h3>Chat</h3>
                    <button id="chatClose" class="chat-close">✕</button>
                </div>
                <div id="chatMessages" class="chat-messages"></div>
                <div class="chat-input-container">
                    <input type="text" id="chatInput" class="chat-input" placeholder="Écrivez votre message...">
                    <button id="chatSend" class="chat-send">📤</button>
                </div>
            </div>
            
            <!-- Panneau de debug (à enlever en prod) -->
            <div id="debugPanel" class="debug-panel" style="display:none;">
                <h4>Journal de débogage</h4>
                <div id="debugLog"></div>
            </div>
        </div>
    </div>

    <script>
    class VideoCallPlatform {
       constructor() {
           // Propriétés principales
           this.localStream = null;
           this.userName = null;
           this.userEmail = null;
           this.userId = null;
           this.roomCode = null;
           this.isInitiator = false;
           this.isDarkMode = document.documentElement.classList.contains('dark');
           this.socket = null;
           this.debugMode = true; // Activer pour le débogage
           
           // Nouvelles propriétés pour la gestion multi-utilisateurs
           this.peers = new Map(); // Map pour stocker les connexions RTC (userId => RTCPeerConnection)
           this.dataChannels = new Map(); // Map pour stocker les canaux de données (userId => RTCDataChannel)
           this.remoteStreams = new Map(); // Map pour stocker les flux distants (userId => MediaStream)
           this.participants = new Map(); // Map pour stocker les infos des participants (userId => {name, connected, etc.})
           this.unreadMessages = 0;
           this.isChatOpen = false;
           
           // État des médias
           this.isAudioMuted = false;
           this.isVideoMuted = false;
           
           // Suivi des messages et état
           this.processedMessages = new Set();
           this.pendingIceCandidates = new Map(); // userId => [candidates]
           
           // Correction du chemin vers l'API
           this.apiEndpoint = window.location.pathname.includes('/room') ? './api' : 'api';
           
           this.initializeElements();
           this.bindEvents();
           this.checkUrlParams();
           this.checkLoginStatus();
       }

       initializeElements() {
           this.elements = {
               // Éléments d'authentification
               authContainer: document.getElementById('authContainer'),
               userDashboard: document.getElementById('userDashboard'),
               loginTab: document.getElementById('loginTab'),
               registerTab: document.getElementById('registerTab'),
               loginBtn: document.getElementById('loginBtn'),
               registerBtn: document.getElementById('registerBtn'),
               loginEmail: document.getElementById('loginEmail'),
               loginPassword: document.getElementById('loginPassword'),
               registerName: document.getElementById('registerName'),
               registerEmail: document.getElementById('registerEmail'),
               registerPassword: document.getElementById('registerPassword'),
               registerPasswordConfirm: document.getElementById('registerPasswordConfirm'),
               loginMessage: document.getElementById('loginMessage'),
               registerMessage: document.getElementById('registerMessage'),
               userNameDisplay: document.getElementById('userNameDisplay'),
               logoutBtn: document.getElementById('logoutBtn'),
               themeToggle: document.getElementById('themeToggle'),
               roomList: document.getElementById('roomList'),
               roomListItems: document.getElementById('roomListItems'),
               
               // Éléments d'interface vidéo
               setupSection: document.getElementById('setupSection'),
               videoContainer: document.getElementById('videoContainer'),
               localVideoMini: document.getElementById('localVideoMini'),
               localVideo: document.getElementById('localVideo'),
               callControls: document.getElementById('callControls'),
               connectionInfo: document.getElementById('connectionInfo'),
               connectionStatus: document.getElementById('connectionStatus'),
               statusMessage: document.getElementById('statusMessage'),
               roomCodeInput: document.getElementById('roomCode'),
               createRoomBtn: document.getElementById('createRoomBtn'),
               joinRoomBtn: document.getElementById('joinRoomBtn'),
               copyCodeBtn: document.getElementById('copyCodeBtn'),
               muteBtn: document.getElementById('muteBtn'),
               videoBtn: document.getElementById('videoBtn'),
               chatBtn: document.getElementById('chatBtn'),
               leaveBtn: document.getElementById('leaveBtn'),
               roomCodeText: document.getElementById('roomCodeText'),
               
               // Nouveaux éléments
               shareLink: document.getElementById('shareLink'),
               copyLinkBtn: document.getElementById('copyLinkBtn'),
               participantsContainer: document.getElementById('participantsContainer'),
               participantsList: document.getElementById('participantsList'),
               participantCount: document.getElementById('participantCount'),
               
               // Chat
               chatToggle: document.getElementById('chatToggle'),
               chatContainer: document.getElementById('chatContainer'),
               chatClose: document.getElementById('chatClose'),
               chatMessages: document.getElementById('chatMessages'),
               chatInput: document.getElementById('chatInput'),
               chatSend: document.getElementById('chatSend'),
               chatNotification: document.getElementById('chatNotification'),
               
               // Débogage
               debugPanel: document.getElementById('debugPanel'),
               debugLog: document.getElementById('debugLog')
           };
           
           // Afficher le panneau de débogage si nécessaire
           if (this.debugMode) {
               this.elements.debugPanel.style.display = 'block';
           }
       }

       bindEvents() {
           // Gestion des onglets d'authentification
           const tabs = document.querySelectorAll('.tab');
           tabs.forEach(tab => {
               tab.addEventListener('click', () => {
                   tabs.forEach(t => t.classList.remove('active'));
                   tab.classList.add('active');
                   
                   document.querySelectorAll('.tab-content').forEach(content => {
                       content.classList.remove('active');
                   });
                   
                   const tabName = tab.getAttribute('data-tab');
                   document.getElementById(`${tabName}Tab`).classList.add('active');
               });
           });
           
           // Authentification
           this.elements.loginBtn.addEventListener('click', () => this.login());
           this.elements.registerBtn.addEventListener('click', () => this.register());
           this.elements.logoutBtn.addEventListener('click', () => this.logout());
           this.elements.themeToggle.addEventListener('click', () => this.toggleTheme());
           
           // Interaction vidéo
           this.elements.createRoomBtn.addEventListener('click', () => this.createRoom());
           this.elements.joinRoomBtn.addEventListener('click', () => this.joinRoom());
           this.elements.copyCodeBtn.addEventListener('click', () => this.copyRoomCode());
           this.elements.copyLinkBtn.addEventListener('click', () => this.copyShareLink());
           this.elements.muteBtn.addEventListener('click', () => this.toggleAudio());
           this.elements.videoBtn.addEventListener('click', () => this.toggleVideo());
           this.elements.leaveBtn.addEventListener('click', () => this.leaveRoom());
           
           // Chat
           this.elements.chatBtn.addEventListener('click', () => this.toggleChat());
           this.elements.chatToggle.addEventListener('click', () => this.toggleChat());
           this.elements.chatClose.addEventListener('click', () => this.toggleChat(false));
           this.elements.chatInput.addEventListener('keypress', (e) => {
               if (e.key === 'Enter') this.sendChatMessage();
           });
           this.elements.chatSend.addEventListener('click', () => this.sendChatMessage());
           
           // Gestion des entrées clavier
           this.elements.roomCodeInput.addEventListener('keypress', (e) => {
               if (e.key === 'Enter') this.joinRoom();
           });
           
           this.elements.loginEmail.addEventListener('keypress', (e) => {
               if (e.key === 'Enter') this.login();
           });
           
           this.elements.loginPassword.addEventListener('keypress', (e) => {
               if (e.key === 'Enter') this.login();
           });
       }

       // Méthode de journalisation pour débogage
       debug(message, type = 'info') {
           if (!this.debugMode) return;
           
           const timestamp = new Date().toLocaleTimeString();
           const entry = document.createElement('div');
           entry.className = `debug-entry ${type}`;
           entry.textContent = `[${timestamp}] ${message}`;
           
           this.elements.debugLog.appendChild(entry);
           this.elements.debugLog.scrollTop = this.elements.debugLog.scrollHeight;
           
           // Aussi en console pour faciliter le débogage
           console.log(`[${type.toUpperCase()}] ${message}`);
       }

       // Vérifier les paramètres d'URL pour rejoindre automatiquement une salle
       checkUrlParams() {
           const urlParams = new URLSearchParams(window.location.search);
           const roomParam = urlParams.get('room');
           
           if (roomParam) {
               this.debug(`Code de salle détecté dans l'URL: ${roomParam}`);
               // Stocker le code pour l'utiliser après la connexion
               this.pendingRoomCode = roomParam;
           }
       }
       
       toggleTheme() {
           this.isDarkMode = !this.isDarkMode;
           if (this.isDarkMode) {
               document.documentElement.classList.add('dark');
               this.elements.themeToggle.textContent = '☀️';
           } else {
               document.documentElement.classList.remove('dark');
               this.elements.themeToggle.textContent = '🌙';
           }
       }

       // Gestion de l'authentification
       async login() {
           const email = this.elements.loginEmail.value.trim();
           const password = this.elements.loginPassword.value;
           
           if (!email || !password) {
               this.showMessage(this.elements.loginMessage, 'Veuillez remplir tous les champs', 'error');
               return;
           }
           
           this.elements.loginBtn.disabled = true;
           this.elements.loginBtn.innerHTML = '<span class="loading"></span> Connexion...';
           
           try {
               const response = await fetch(`${this.apiEndpoint}/login.php`, {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({ email, password })
               });
               
               const data = await response.json();
               
               if (data.success) {
                   this.userId = data.userId;
                   this.userName = data.name;
                   this.userEmail = email;
                   
                   this.showUserDashboard();
                   this.loadUserRooms();
                   this.connectToSignalingServer();
                   
                   // Si un code de salle était en attente dans l'URL, rejoindre automatiquement
                   if (this.pendingRoomCode) {
                       this.elements.roomCodeInput.value = this.pendingRoomCode;
                       setTimeout(() => this.joinRoom(), 1000);
                       this.pendingRoomCode = null;
                   }
               } else {
                   this.showMessage(this.elements.loginMessage, data.message || 'Erreur de connexion', 'error');
               }
           } catch (error) {
               console.error('Erreur de connexion:', error);
               this.showMessage(this.elements.loginMessage, 'Erreur de serveur', 'error');
           } finally {
               this.elements.loginBtn.disabled = false;
               this.elements.loginBtn.textContent = 'Se connecter';
           }
       }
       
       async register() {
           const name = this.elements.registerName.value.trim();
           const email = this.elements.registerEmail.value.trim();
           const password = this.elements.registerPassword.value;
           const confirmPassword = this.elements.registerPasswordConfirm.value;
           
           if (!name || !email || !password || !confirmPassword) {
               this.showMessage(this.elements.registerMessage, 'Veuillez remplir tous les champs', 'error');
               return;
           }
           
           if (password !== confirmPassword) {
               this.showMessage(this.elements.registerMessage, 'Les mots de passe ne correspondent pas', 'error');
               return;
           }
           
           this.elements.registerBtn.disabled = true;
           this.elements.registerBtn.innerHTML = '<span class="loading"></span> Inscription...';
           
           try {
               const response = await fetch(`${this.apiEndpoint}/register.php`, {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({ name, email, password })
               });
               
               const data = await response.json();
               
               if (data.success) {
                   this.showMessage(this.elements.registerMessage, 'Inscription réussie ! Vous pouvez vous connecter.', 'success');
                   
                   // Pré-remplir les champs de connexion
                   this.elements.loginEmail.value = email;
                   
                   // Basculer vers l'onglet de connexion
                   document.querySelector('.tab[data-tab="login"]').click();
               } else {
                   this.showMessage(this.elements.registerMessage, data.message || 'Erreur d\'inscription', 'error');
               }
           } catch (error) {
               console.error('Erreur d\'inscription:', error);
               this.showMessage(this.elements.registerMessage, 'Erreur de serveur', 'error');
           } finally {
               this.elements.registerBtn.disabled = false;
               this.elements.registerBtn.textContent = 'S\'inscrire';
           }
       }
       
       async checkLoginStatus() {
           try {
               const response = await fetch(`${this.apiEndpoint}/check_session.php`);
               const data = await response.json();
               
               if (data.loggedIn) {
                   this.userId = data.userId;
                   this.userName = data.name;
                   this.userEmail = data.email;
                   
                   this.showUserDashboard();
                   this.loadUserRooms();
                   this.connectToSignalingServer();
                   
                   // Si un code de salle était en attente dans l'URL, rejoindre automatiquement
                   if (this.pendingRoomCode) {
                       this.elements.roomCodeInput.value = this.pendingRoomCode;
                       setTimeout(() => this.joinRoom(), 1000);
                       this.pendingRoomCode = null;
                   }
               }
           } catch (error) {
               console.error('Erreur de vérification de session:', error);
           }
       }
       
       async logout() {
           try {
               await fetch(`${this.apiEndpoint}/logout.php`);
               
               // Fermer toute connexion WebRTC en cours
               this.leaveRoom();
               
               // Fermer la connexion WebSocket
               if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                   this.socket.close();
               }
               
               // Réinitialiser les données utilisateur
               this.userId = null;
               this.userName = null;
               this.userEmail = null;
               
               // Revenir à l'écran de connexion
               this.elements.authContainer.style.display = 'block';
               this.elements.userDashboard.style.display = 'none';
               
               // Vider les champs de formulaire
               this.elements.loginEmail.value = '';
               this.elements.loginPassword.value = '';
           } catch (error) {
               console.error('Erreur de déconnexion:', error);
           }
       }
       
       showUserDashboard() {
           this.elements.authContainer.style.display = 'none';
           this.elements.userDashboard.style.display = 'block';
           this.elements.userNameDisplay.textContent = this.userName;
           this.elements.themeToggle.textContent = this.isDarkMode ? '☀️' : '🌙';
       }
       
       async loadUserRooms() {
           try {
               const response = await fetch(`${this.apiEndpoint}/get_user_rooms.php`);
               const data = await response.json();
               
               if (data.success) {
                   const roomsHTML = data.rooms.length > 0 
                       ? data.rooms.map(room => `
                           <div class="room-item">
                               <div>
                                   <strong>${room.name || 'Salle sans nom'}</strong>
                                   <div>Code: <span class="room-code-small">${room.code}</span></div>
                               </div>
                               <button class="btn btn-secondary" 
                                       onclick="window.videoCallApp.joinExistingRoom('${room.code}')">
                                   Rejoindre
                               </button>
                           </div>
                       `).join('')
                       : '<div class="room-item">Aucune salle récente</div>';
                   
                   this.elements.roomListItems.innerHTML = roomsHTML;
               } else {
                   this.elements.roomListItems.innerHTML = '<div class="room-item">Impossible de charger vos salles</div>';
               }
           } catch (error) {
               console.error('Erreur de chargement des salles:', error);
               this.elements.roomListItems.innerHTML = '<div class="room-item">Erreur de serveur</div>';
           }
       }
       
       joinExistingRoom(roomCode) {
           this.elements.roomCodeInput.value = roomCode;
           this.joinRoom();
       }

       connectToSignalingServer() {
           // Configuration du WebSocket - Utilisez wss:// pour une connexion sécurisée en production
           // Utilisez une URL de serveur de signalisation accessible par les deux clients
           const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
           const wsHost = window.location.hostname;
           const wsPort = '8080'; // Assurez-vous que ce port est accessible
           const wsUrl = `${wsProtocol}//${wsHost}:${wsPort}`;
           
           this.debug(`Connexion au serveur de signalisation: ${wsUrl}`);
           
           // Fermer la connexion existante si elle existe
           if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
               this.socket.close();
           }
           
           try {
               this.socket = new WebSocket(wsUrl);
               
               this.socket.onopen = () => {
                   this.debug('Connexion WebSocket établie');
                   
                   // Envoyer un message d'identification
                   if (this.userId && this.userName) {
                       this.sendSignalingMessage({
                           type: 'register',
                           userId: this.userId,
                           userName: this.userName
                       });
                   }
               };
               
               this.socket.onmessage = (event) => {
                   try {
                       const message = JSON.parse(event.data);
                       
                       // Générer un ID unique pour le message pour éviter les doublons
                       const messageId = this.generateMessageId(message);
                       
                       // Vérifier si le message a déjà été traité
                       if (this.processedMessages.has(messageId)) {
                           this.debug(`Message déjà traité, ignoré: ${messageId}`);
                           return;
                       }
                       
                       // Marquer le message comme traité
                       this.processedMessages.add(messageId);
                       
                       // Limiter la taille du set pour éviter les fuites de mémoire
                       if (this.processedMessages.size > 100) {
                           const toRemove = Array.from(this.processedMessages).slice(0, 50);
                           toRemove.forEach(id => this.processedMessages.delete(id));
                       }
                       
                       this.debug(`Message reçu: ${JSON.stringify(message)}`);
                       this.handleSignalingMessage(message);
                   } catch (error) {
                       this.debug(`Erreur de parsing du message: ${error.message}`, 'error');
                   }
               };
               
               this.socket.onclose = (event) => {
                   this.debug(`Connexion WebSocket fermée: Code ${event.code}, Raison: ${event.reason}`);
                   
                   // Tenter de se reconnecter après un délai
                   setTimeout(() => {
                       if (this.userId) {
                           this.debug('Tentative de reconnexion au serveur de signalisation...');
                           this.connectToSignalingServer();
                       }
                   }, 5000);
               };
               
               this.socket.onerror = (error) => {
                   this.debug(`Erreur WebSocket: ${error}`, 'error');
               };
           } catch (error) {
               this.debug(`Erreur lors de la création de WebSocket: ${error.message}`, 'error');
           }
       }
       
       // Générer un ID unique pour chaque message
       generateMessageId(message) {
           // Créer une chaîne qui représente de manière unique le message
           const stringToHash = `${message.type}-${message.roomCode || ''}-${
               message.senderId || ''}-${message.senderName || ''}-${
               JSON.stringify(message.offer || message.answer || message.candidate || {})
           }`;
           
           // Méthode simple de hachage pour créer un ID court
           let hash = 0;
           for (let i = 0; i < stringToHash.length; i++) {
               const char = stringToHash.charCodeAt(i);
               hash = ((hash << 5) - hash) + char;
               hash = hash & hash; // Conversion en entier 32 bits
           }
           
           return `${message.type}-${hash}`;
       }

       setupPeerConnection(remotePeerId) {
           // Configuration avec plus de serveurs STUN/TURN pour améliorer la connectivité
           const configuration = {
               iceServers: [
                   { urls: 'stun:stun.l.google.com:19302' },
                   { urls: 'stun:stun1.l.google.com:19302' },
                   { urls: 'stun:stun2.l.google.com:19302' },
                   { urls: 'stun:stun3.l.google.com:19302' },
                   { urls: 'stun:stun4.l.google.com:19302' }
               ],
               iceCandidatePoolSize: 10,
               bundlePolicy: 'max-bundle',
               rtcpMuxPolicy: 'require',
               sdpSemantics: 'unified-plan'
           };
           
           // Vérifier si une connexion existe déjà pour ce pair
           if (this.peers.has(remotePeerId)) {
               this.debug(`Nettoyage de l'ancienne connexion peer pour ${remotePeerId}`);
               const oldPeer = this.peers.get(remotePeerId);
               oldPeer.close();
           }
           
           this.debug(`Création de la connexion RTCPeerConnection pour ${remotePeerId}`);
           const peerConnection = new RTCPeerConnection(configuration);
           
           // Stocker la connexion
           this.peers.set(remotePeerId, peerConnection);
           
           // Initialiser l'état de collecte ICE
           const peerState = {
               iceGatheringComplete: false,
               signalingState: 'stable'
           };

           // Suivi de l'état de signalisation pour éviter les erreurs de synchronisation
           peerConnection.onsignalingstatechange = () => {
               peerState.signalingState = peerConnection.signalingState;
               this.debug(`État de signalisation pour ${remotePeerId}: ${peerState.signalingState}`);
           };

           // Gestion des candidats ICE
           peerConnection.onicecandidate = (event) => {
               if (event.candidate) {
                   this.debug(`Nouveau candidat ICE pour ${remotePeerId}: ${JSON.stringify(event.candidate)}`);
                   
                   // Envoyer le candidat ICE au pair distant
                   this.sendSignalingMessage({
                       type: 'ice-candidate',
                       candidate: event.candidate,
                       roomCode: this.roomCode,
                       senderName: this.userName,
                       senderId: this.userId,
                       targetId: remotePeerId
                   });
               } else {
                   // Collecte de candidats ICE terminée
                   this.debug(`Collecte de candidats ICE terminée pour ${remotePeerId}`);
                   peerState.iceGatheringComplete = true;
               }
           };
           
           // Suivi de l'état de la collecte ICE
           peerConnection.onicegatheringstatechange = () => {
               this.debug(`État de collecte ICE pour ${remotePeerId}: ${peerConnection.iceGatheringState}`);
           };
           
           // Suivi de l'état de la connexion ICE
           peerConnection.oniceconnectionstatechange = () => {
               this.debug(`État de connexion ICE pour ${remotePeerId}: ${peerConnection.iceConnectionState}`);
               
               // Mettre à jour l'interface utilisateur en fonction de l'état
               if (peerConnection.iceConnectionState === 'connected' || 
                   peerConnection.iceConnectionState === 'completed') {
                   this.debug(`Connexion ICE établie avec ${remotePeerId}`);
                   
                   // Mettre à jour l'état du participant
                   if (this.participants.has(remotePeerId)) {
                       const participant = this.participants.get(remotePeerId);
                       participant.connected = true;
                       this.updateParticipantsList();
                   }
                   
                   // Masquer le message d'attente
                   const videoBox = document.getElementById(`video-box-${remotePeerId}`);
                   if (videoBox) {
                       const waitingMsg = videoBox.querySelector('.waiting-message');
                       if (waitingMsg) waitingMsg.style.display = 'none';
                       
                       const videoLabel = videoBox.querySelector('.video-label');
                       if (videoLabel) videoLabel.style.display = 'block';
                   }
               } else if (peerConnection.iceConnectionState === 'failed') {
                   this.debug(`Échec de la connexion ICE avec ${remotePeerId}`, 'error');
                   
                   // Mettre à jour l'état du participant
                   if (this.participants.has(remotePeerId)) {
                       const participant = this.participants.get(remotePeerId);
                       participant.connected = false;
                       this.updateParticipantsList();
                   }
                   
                   // Afficher message d'erreur
                   const videoBox = document.getElementById(`video-box-${remotePeerId}`);
                   if (videoBox) {
                       const waitingMsg = videoBox.querySelector('.waiting-message');
                       if (waitingMsg) {
                           waitingMsg.textContent = 'Connexion échouée';
                           waitingMsg.style.display = 'flex';
                       }
                   }
               } else if (peerConnection.iceConnectionState === 'disconnected') {
                   this.debug(`Connexion ICE déconnectée avec ${remotePeerId}`);
                   
                   // Mettre à jour l'état du participant
                   if (this.participants.has(remotePeerId)) {
                       const participant = this.participants.get(remotePeerId);
                       participant.connected = false;
                       this.updateParticipantsList();
                   }
                   
                   // Afficher message de déconnexion
                   const videoBox = document.getElementById(`video-box-${remotePeerId}`);
                   if (videoBox) {
                       const waitingMsg = videoBox.querySelector('.waiting-message');
                       if (waitingMsg) {
                           waitingMsg.textContent = 'Connexion perdue, tentative de reconnexion...';
                           waitingMsg.style.display = 'flex';
                       }
                   }
               }
           };

           // Réception des flux distants
           peerConnection.ontrack = (event) => {
               this.debug(`Flux distant reçu de ${remotePeerId}: ${event.track.kind}`);
               
               // S'assurer que le flux distant est bien configuré
               if (!this.remoteStreams.has(remotePeerId)) {
                   this.remoteStreams.set(remotePeerId, new MediaStream());
                   
                   // Créer ou mettre à jour l'élément vidéo
                   this.createOrUpdateVideoElement(remotePeerId);
               }
               
               const remoteStream = this.remoteStreams.get(remotePeerId);
               
               // Ajouter la piste au flux distant
               remoteStream.addTrack(event.track);
               
               // Mettre à jour l'interface utilisateur
               const videoElem = document.getElementById(`remote-video-${remotePeerId}`);
               if (videoElem) {
                   videoElem.srcObject = remoteStream;
                   
                   // Cacher le message d'attente seulement après l'ajout de pistes audio et vidéo
                   if (remoteStream.getVideoTracks().length > 0 && 
                       remoteStream.getAudioTracks().length > 0) {
                       const waitingMsg = document.getElementById(`waiting-message-${remotePeerId}`);
                       if (waitingMsg) waitingMsg.style.display = 'none';
                       
                       const videoLabel = document.getElementById(`video-label-${remotePeerId}`);
                       if (videoLabel) videoLabel.style.display = 'block';
                   }
               }
           };

           // État de la connexion
           peerConnection.onconnectionstatechange = () => {
               this.debug(`État de connexion P2P pour ${remotePeerId}: ${peerConnection.connectionState}`);
               
               if (peerConnection.connectionState === 'connected') {
                   // Mettre à jour l'état du participant
                   if (this.participants.has(remotePeerId)) {
                       const participant = this.participants.get(remotePeerId);
                       participant.connected = true;
                       this.updateParticipantsList();
                   }
                   
                   this.updateStatus('✅ Connexion établie avec succès !', 'success');
               } else if (peerConnection.connectionState === 'failed') {
                   // Mettre à jour l'état du participant
                   if (this.participants.has(remotePeerId)) {
                       const participant = this.participants.get(remotePeerId);
                       participant.connected = false;
                       this.updateParticipantsList();
                   }
                   
                   this.updateStatus('❌ Échec de la connexion', 'error');
               } else if (peerConnection.connectionState === 'disconnected') {
                   // Mettre à jour l'état du participant
                   if (this.participants.has(remotePeerId)) {
                       const participant = this.participants.get(remotePeerId);
                       participant.connected = false;
                       this.updateParticipantsList();
                   }
               }
               
               // Mettre à jour la grille de vidéos
               this.updateVideoGrid();
           };

           // Canal de données pour les messages
           // Si c'est l'initiateur, créer le canal de données
           if (this.isInitiator) {
               this.debug(`Création du canal de données pour ${remotePeerId}`);
               const dataChannel = peerConnection.createDataChannel('messages', {
                   ordered: true,
                   negotiated: false
               });
               this.dataChannels.set(remotePeerId, dataChannel);
               this.setupDataChannel(remotePeerId, dataChannel);
           }

           peerConnection.ondatachannel = (event) => {
               this.debug(`Canal de données reçu de ${remotePeerId}`);
               this.dataChannels.set(remotePeerId, event.channel);
               this.setupDataChannel(remotePeerId, event.channel);
           };
           
           return peerConnection;
       }

       setupDataChannel(remotePeerId, dataChannel) {
           if (!dataChannel) {
               this.debug(`Canal de données non disponible pour ${remotePeerId}`, 'error');
               return;
           }
           
           dataChannel.onopen = () => {
               this.debug(`Canal de données ouvert avec ${remotePeerId}`);
               
               // Envoyer les informations de l'utilisateur via le canal de données
               if (dataChannel.readyState === 'open') {
                   const userInfo = {
                       type: 'user-info',
                       name: this.userName,
                       id: this.userId
                   };
                   
                   try {
                       dataChannel.send(JSON.stringify(userInfo));
                       this.debug(`Informations utilisateur envoyées à ${remotePeerId}`);
                   } catch (error) {
                       this.debug(`Erreur lors de l'envoi des informations à ${remotePeerId}: ${error.message}`, 'error');
                   }
               }
           };

           dataChannel.onmessage = (event) => {
               try {
                   const data = JSON.parse(event.data);
                   this.debug(`Message reçu via le canal de données de ${remotePeerId}: ${JSON.stringify(data)}`);
                   
                   if (data.type === 'user-info') {
                       // Mettre à jour les informations de l'utilisateur distant
                       if (this.participants.has(remotePeerId)) {
                           const participant = this.participants.get(remotePeerId);
                           participant.name = data.name;
                           this.updateParticipantsList();
                       } else {
                           this.participants.set(remotePeerId, {
                               id: data.id,
                               name: data.name,
                               connected: true
                           });
                           this.updateParticipantsList();
                       }
                       
                       // Mettre à jour l'étiquette vidéo
                       const videoLabel = document.getElementById(`video-label-${remotePeerId}`);
                       if (videoLabel) {
                           videoLabel.textContent = data.name;
                           videoLabel.style.display = 'block';
                       }
                       
                       // Créer ou mettre à jour l'élément vidéo
                       this.createOrUpdateVideoElement(remotePeerId);
                   } else if (data.type === 'chat-message') {
                       // Afficher le message de chat
                       this.displayChatMessage(data.senderId, data.senderName, data.message, false);
                   }
               } catch (error) {
                   this.debug(`Erreur de parsing du message: ${error.message}`, 'error');
               }
           };
           
           dataChannel.onclose = () => {
               this.debug(`Canal de données fermé avec ${remotePeerId}`);
           };
           
           dataChannel.onerror = (error) => {
               this.debug(`Erreur du canal de données avec ${remotePeerId}: ${error}`, 'error');
           };
       }
       
       // Créer ou mettre à jour l'élément vidéo pour un participant
       createOrUpdateVideoElement(remotePeerId) {
           // Vérifier si l'élément existe déjà
           let videoBox = document.getElementById(`video-box-${remotePeerId}`);
           
           if (!videoBox) {
               // Créer un nouvel élément
               videoBox = document.createElement('div');
               videoBox.id = `video-box-${remotePeerId}`;
               videoBox.className = 'video-box';
               
               // Créer l'élément vidéo
               const videoElem = document.createElement('video');
               videoElem.id = `remote-video-${remotePeerId}`;
               videoElem.autoplay = true;
               videoElem.playsinline = true;
               
               // Si nous avons déjà un flux, l'associer
               if (this.remoteStreams.has(remotePeerId)) {
                   videoElem.srcObject = this.remoteStreams.get(remotePeerId);
               }
               
               // Créer l'étiquette de vidéo
               const videoLabel = document.createElement('div');
               videoLabel.id = `video-label-${remotePeerId}`;
               videoLabel.className = 'video-label';
               
               // Obtenir le nom du participant s'il existe
               const participantName = this.participants.has(remotePeerId) ? 
                   this.participants.get(remotePeerId).name : 'Participant';
               videoLabel.textContent = participantName;
               
               // Créer le message d'attente
               const waitingMessage = document.createElement('div');
               waitingMessage.id = `waiting-message-${remotePeerId}`;
               waitingMessage.className = 'waiting-message';
               waitingMessage.textContent = 'En attente de connexion...';
               
               // Assembler le tout
               videoBox.appendChild(videoElem);
               videoBox.appendChild(waitingMessage);
               videoBox.appendChild(videoLabel);
               
               // Ajouter au conteneur
               this.elements.videoContainer.appendChild(videoBox);
               
               // Mettre à jour la disposition de la grille
               this.updateVideoGrid();
           } else {
               // Mettre à jour l'élément existant
               const videoElem = document.getElementById(`remote-video-${remotePeerId}`);
               if (videoElem && this.remoteStreams.has(remotePeerId)) {
                   videoElem.srcObject = this.remoteStreams.get(remotePeerId);
               }
               
               // Mettre à jour l'étiquette
               const videoLabel = document.getElementById(`video-label-${remotePeerId}`);
               if (videoLabel && this.participants.has(remotePeerId)) {
                   videoLabel.textContent = this.participants.get(remotePeerId).name;
               }
           }
       }
       
       // Mettre à jour la grille vidéo en fonction du nombre de participants
       updateVideoGrid() {
           // Compter le nombre de participants (vidéo locale + participants distants)
           const participantCount = this.participants.size + 1; // +1 pour l'utilisateur local
           
           // Mettre à jour le compteur de participants
           this.elements.participantCount.textContent = participantCount;
           
           // Mettre à jour la classe pour la disposition de la grille
           this.elements.videoContainer.className = `video-container active participants-${participantCount}`;
           
           // Afficher la vidéo locale en miniature s'il y a plus d'un participant
           if (participantCount > 1) {
               this.elements.localVideoMini.style.display = 'block';
           } else {
               this.elements.localVideoMini.style.display = 'none';
               
               // Si seul, afficher la vidéo locale dans la grille principale
               let localVideoBox = document.getElementById('video-box-local');
               if (!localVideoBox) {
                   localVideoBox = document.createElement('div');
                   localVideoBox.id = 'video-box-local';
                   localVideoBox.className = 'video-box';
                   
                   const videoClone = document.createElement('video');
                   videoClone.id = 'local-video-main';
                   videoClone.autoplay = true;
                   videoClone.muted = true;
                   videoClone.playsinline = true;
                   
                   if (this.localStream) {
                       videoClone.srcObject = this.localStream;
                   }
                   
                   const videoLabel = document.createElement('div');
                   videoLabel.className = 'video-label';
                   videoLabel.textContent = 'Vous';
                   
                   localVideoBox.appendChild(videoClone);
                   localVideoBox.appendChild(videoLabel);
                   
                   this.elements.videoContainer.appendChild(localVideoBox);
               }
           }
       }
       
       // Mettre à jour la liste des participants
       updateParticipantsList() {
           // Afficher le conteneur des participants
           this.elements.participantsContainer.style.display = 'block';
           
           // Mettre à jour le compteur
           this.elements.participantCount.textContent = this.participants.size + 1; // +1 pour l'utilisateur local
           
           // Vider la liste actuelle
           this.elements.participantsList.innerHTML = '';
           
           // Ajouter l'utilisateur courant
           const localParticipant = document.createElement('li');
           localParticipant.className = 'participant-item';
           
           const localAvatar = document.createElement('div');
           localAvatar.className = 'participant-avatar';
           localAvatar.textContent = this.userName.charAt(0).toUpperCase();
           
           const localName = document.createElement('div');
           localName.className = 'participant-name';
           localName.textContent = `${this.userName} (Vous)`;
           
           const localStatus = document.createElement('div');
           localStatus.className = 'participant-status';
           
           localParticipant.appendChild(localAvatar);
           localParticipant.appendChild(localName);
           localParticipant.appendChild(localStatus);
           
           this.elements.participantsList.appendChild(localParticipant);
           
           // Ajouter les autres participants
           this.participants.forEach((participant, id) => {
               const item = document.createElement('li');
               item.className = 'participant-item';
               
               const avatar = document.createElement('div');
               avatar.className = 'participant-avatar';
               avatar.textContent = participant.name.charAt(0).toUpperCase();
               
               const name = document.createElement('div');
               name.className = 'participant-name';
               name.textContent = participant.name;
               
               const status = document.createElement('div');
               status.className = `participant-status ${participant.connected ? '' : 'offline'}`;
               
               item.appendChild(avatar);
               item.appendChild(name);
               item.appendChild(status);
               
               this.elements.participantsList.appendChild(item);
           });
       }

       async createRoom() {
           this.elements.createRoomBtn.disabled = true;
           this.elements.createRoomBtn.innerHTML = '<span class="loading"></span> Création...';
           
           this.debug('Création d\'une nouvelle salle');

           try {
               const response = await fetch(`${this.apiEndpoint}/create_room.php`, {
                   method: 'POST'
               });
               
               if (!response.ok) {
                   throw new Error(`HTTP error! status: ${response.status}`);
               }
               
               const data = await response.json();
               
               if (data.success) {
                   this.roomCode = data.roomCode;
                   this.isInitiator = true;
                   this.processedMessages.clear(); // Réinitialiser les messages traités
                   
                   // Ajouter l'utilisateur local à la liste des participants
                   this.participants.set(this.userId, {
                       id: this.userId,
                       name: this.userName,
                       connected: true
                   });
                   
                   this.debug(`Salle créée avec le code: ${this.roomCode}`);
                   
                   await this.initializeMedia();
                   this.showRoomInfo();
                   this.updateStatus('Salle créée ! En attente de connexion...', 'info');
                   
                   // Générer et afficher le lien partageable
                   this.generateShareLink();
                   
                   // Mettre à jour la liste des participants
                   this.updateParticipantsList();
                   
                   // Mettre à jour la grille vidéo
                   this.updateVideoGrid();
                   
                   // Enregistrement auprès du serveur de signalisation pour cette salle
                   this.sendSignalingMessage({
                       type: 'room-created',
                       roomCode: this.roomCode,
                       creatorId: this.userId,
                       creatorName: this.userName
                   });
               } else {
                   this.debug(`Erreur lors de la création de la salle: ${data.message}`, 'error');
                   this.updateStatus(data.message || 'Erreur de création de salle', 'error');
               }
           } catch (error) {
               this.debug(`Erreur lors de la création: ${error.message}`, 'error');
               this.updateStatus('Erreur de serveur', 'error');
           } finally {
               this.elements.createRoomBtn.disabled = false;
               this.elements.createRoomBtn.textContent = 'Créer une nouvelle salle';
           }
       }

       async joinRoom() {
           const roomCode = this.elements.roomCodeInput.value.trim().toUpperCase();

           if (!roomCode) {
               this.updateStatus('Veuillez entrer un code de salle', 'error');
               return;
           }
           
           this.debug(`Tentative de rejoindre la salle: ${roomCode}`);

           this.elements.joinRoomBtn.disabled = true;
           this.elements.joinRoomBtn.innerHTML = '<span class="loading"></span> Connexion...';

           try {
               const response = await fetch(`${this.apiEndpoint}/join_room.php`, {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({ roomCode })
               });

               // Vérification que la réponse est valide avant de parser le JSON
               if (!response.ok) {
                   throw new Error(`HTTP error! status: ${response.status}`);
               }

               const data = await response.json();
               
               if (data.success) {
                   this.roomCode = roomCode;
                   this.isInitiator = false;
                   this.processedMessages.clear(); // Réinitialiser les messages traités
                   
                   // Ajouter l'utilisateur local à la liste des participants
                   this.participants.set(this.userId, {
                       id: this.userId,
                       name: this.userName,
                       connected: true
                   });
                   
                   this.debug(`Salle rejointe avec le code: ${this.roomCode}`);
                   
                   await this.initializeMedia();
                   this.showCallInterface();
                   
                   // Générer et afficher le lien partageable
                   this.generateShareLink();
                   
                   // Mettre à jour la liste des participants
                   this.updateParticipantsList();
                   
                   // Mettre à jour la grille vidéo
                   this.updateVideoGrid();
                   
                   // Envoyer une demande de connexion avec plus d'informations
                   this.sendSignalingMessage({
                       type: 'join-request',
                       roomCode: this.roomCode,
                       senderId: this.userId,
                       senderName: this.userName
                   });

                   this.updateStatus('Tentative de connexion...', 'info');
               } else {
                   this.debug(`Erreur lors de la connexion à la salle: ${data.message}`, 'error');
                   this.updateStatus(data.message || 'Salle introuvable ou expirée', 'error');
               }
           } catch (error) {
               this.debug(`Erreur lors de la connexion: ${error.message}`, 'error');
               this.updateStatus('Erreur de serveur', 'error');
           } finally {
               this.elements.joinRoomBtn.disabled = false;
               this.elements.joinRoomBtn.textContent = 'Rejoindre';
           }
       }

       async initializeMedia() {
           this.debug('Initialisation des flux média');
           try {
               // S'assurer que les contraintes sont correctement définies
               const constraints = {
                   audio: {
                       echoCancellation: true,
                       noiseSuppression: true,
                       autoGainControl: true
                   },
                   video: {
                       width: { ideal: 1280, max: 1920 },
                       height: { ideal: 720, max: 1080 },
                       frameRate: { ideal: 30, max: 60 }
                   }
               };
               
               this.debug('Demande d\'accès aux périphériques média');
               this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
               
               this.debug(`Flux obtenu: Audio: ${this.localStream.getAudioTracks().length > 0}, Vidéo: ${this.localStream.getVideoTracks().length > 0}`);
               
               // Afficher le flux local
               this.elements.localVideo.srcObject = this.localStream;
           } catch (error) {
               this.debug(`Erreur d'accès aux médias: ${error.message}`, 'error');
               throw new Error('Impossible d\'accéder à la caméra/microphone');
           }
       }
       
       // Génération d'un lien partageable
       generateShareLink() {
           const currentUrl = new URL(window.location.href);
           
           // Supprimer les paramètres existants et ajouter le code de salle
           currentUrl.search = '';
           currentUrl.searchParams.set('room', this.roomCode);
           
           const shareUrl = currentUrl.toString();
           this.elements.shareLink.textContent = shareUrl;
           
           return shareUrl;
       }
       
       // Copier le lien partageable
       async copyShareLink() {
           try {
               const shareLink = this.elements.shareLink.textContent;
               await navigator.clipboard.writeText(shareLink);
               
               this.elements.copyLinkBtn.textContent = '✅';
               setTimeout(() => {
                   this.elements.copyLinkBtn.textContent = '📋';
               }, 2000);
           } catch (error) {
               this.debug(`Erreur lors de la copie du lien: ${error.message}`, 'error');
           }
       }

       showRoomInfo() {
           this.elements.setupSection.style.display = 'none';
           this.elements.roomList.style.display = 'none';
           this.elements.connectionInfo.style.display = 'block';
           this.elements.roomCodeText.textContent = this.roomCode;
           this.elements.videoContainer.classList.add('active');
           this.elements.callControls.classList.add('active');
           this.elements.chatToggle.classList.add('active');
       }

       showCallInterface() {
           this.elements.setupSection.style.display = 'none';
           this.elements.roomList.style.display = 'none';
           this.elements.videoContainer.classList.add('active');
           this.elements.callControls.classList.add('active');
           this.elements.chatToggle.classList.add('active');
       }

       async copyRoomCode() {
           try {
               await navigator.clipboard.writeText(this.roomCode);
               this.elements.copyCodeBtn.textContent = '✅ Copié !';
               setTimeout(() => {
                   this.elements.copyCodeBtn.textContent = '📋 Copier';
               }, 2000);
           } catch (error) {
               this.debug(`Erreur lors de la copie: ${error.message}`, 'error');
           }
       }
       
       // Fonction d'attente pour quelques candidats ICE au lieu d'attendre la fin complète
       waitForSomeIceCandidates(remotePeerId) {
           return new Promise((resolve) => {
               let candidateCount = 0;
               const checkCandidates = () => {
                   candidateCount++;
                   
                   // Si nous avons suffisamment de candidats ou que la collecte est terminée
                   if (candidateCount >= 5 || 
                       !this.peers.has(remotePeerId) || 
                       this.peers.get(remotePeerId).iceGatheringState === 'complete') {
                       this.debug(`Collection de ${candidateCount} candidats ICE suffisante pour ${remotePeerId}`);
                       resolve();
                   } else {
                       setTimeout(checkCandidates, 200);
                   }
               };
               
               // Délai maximum d'attente (2 secondes)
               setTimeout(() => {
                   this.debug(`Délai d'attente de collecte ICE atteint pour ${remotePeerId}`);
                   resolve();
               }, 2000);
               
               // Vérification immédiate
               checkCandidates();
           });
       }

       sendSignalingMessage(message) {
           if (this.socket && this.socket.readyState === WebSocket.OPEN) {
               // Ajouter toujours l'identité de l'expéditeur aux messages
               if (!message.senderId) message.senderId = this.userId;
               if (!message.senderName) message.senderName = this.userName;
               
               // Ajouter un timestamp pour aider à identifier les messages uniques
               message.timestamp = Date.now();
               
               const jsonMessage = JSON.stringify(message);
               this.debug(`Envoi du message: ${jsonMessage}`);
               this.socket.send(jsonMessage);
           } else {
               this.debug('WebSocket non connecté', 'error');
               this.updateStatus('Erreur de connexion au serveur de signalisation', 'error');
           }
       }

       async handleSignalingMessage(message) {
           this.debug(`Traitement du message de signalisation: ${JSON.stringify(message)}`);
           
           try {
               // Vérifier si le message est pertinent pour nous
               if (message.roomCode !== this.roomCode && 
                   message.type !== 'register') {
                   this.debug('Message ignoré car pas pour notre salle');
                   return;
               }
               
               // Si le message est ciblé, vérifier que c'est pour nous
               if (message.targetId && message.targetId !== this.userId) {
                   this.debug(`Message ignoré car ciblé pour ${message.targetId}`);
                   return;
               }
               
               switch (message.type) {
                   case 'join-request':
                       if (this.isInitiator && message.roomCode === this.roomCode) {
                           this.debug(`Demande de connexion reçue de: ${message.senderName} (${message.senderId})`);
                           
                           // Ajouter le nouveau participant
                           this.participants.set(message.senderId, {
                               id: message.senderId,
                               name: message.senderName,
                               connected: false
                           });
                           
                           // Mettre à jour la liste des participants
                           this.updateParticipantsList();
                           
                           // Créer ou obtenir la connexion peer pour ce participant
                           const peerConnection = this.setupPeerConnection(message.senderId);
                           
                           // Ajouter les pistes média locales
                           if (this.localStream) {
                               this.localStream.getTracks().forEach(track => {
                                   peerConnection.addTrack(track, this.localStream);
                               });
                           }
                           
                           await this.createOfferForPeer(message.senderId);
                       }
                       break;
                       
                   case 'offer':
                       if (!this.isInitiator && message.roomCode === this.roomCode) {
                           this.debug(`Offre reçue de: ${message.senderName} (${message.senderId})`);
                           
                           // Ajouter l'initiateur comme participant
                           this.participants.set(message.senderId, {
                               id: message.senderId,
                               name: message.senderName,
                               connected: false
                           });
                           
                           // Mettre à jour la liste des participants
                           this.updateParticipantsList();
                           
                           // Créer ou obtenir la connexion peer pour ce participant
                           const peerConnection = this.setupPeerConnection(message.senderId);
                           
                           // Ajouter les pistes média locales
                           if (this.localStream) {
                               this.localStream.getTracks().forEach(track => {
                                   peerConnection.addTrack(track, this.localStream);
                               });
                           }
                           
                           await this.handleOffer(message);
                       }
                       break;
                       
                   case 'answer':
                       if (message.roomCode === this.roomCode) {
                           this.debug(`Réponse reçue de: ${message.senderName} (${message.senderId})`);
                           await this.handleAnswer(message);
                       }
                       break;
                       
                   case 'ice-candidate':
                       if (message.roomCode === this.roomCode) {
                           this.debug(`Candidat ICE reçu de: ${message.senderName} (${message.senderId})`);
                           await this.handleIceCandidate(message);
                       }
                       break;
                       
                   case 'user-joined':
                       if (message.roomCode === this.roomCode && message.senderId !== this.userId) {
                           this.debug(`Utilisateur ${message.senderName} (${message.senderId}) a rejoint la salle`);
                           
                           // Ajouter le nouvel utilisateur à la liste des participants
                           this.participants.set(message.senderId, {
                               id: message.senderId,
                               name: message.senderName,
                               connected: false
                           });
                           
                           // Mettre à jour la liste des participants
                           this.updateParticipantsList();
                           
                           // Si je suis l'initiateur, établir une connexion avec le nouveau participant
                           if (this.isInitiator) {
                               // Créer une connexion peer pour le nouveau participant
                               const peerConnection = this.setupPeerConnection(message.senderId);
                               
                               // Ajouter les pistes média locales
                               if (this.localStream) {
                                   this.localStream.getTracks().forEach(track => {
                                       peerConnection.addTrack(track, this.localStream);
                                   });
                               }
                               
                               // Créer et envoyer une offre
                               await this.createOfferForPeer(message.senderId);
                           }
                       }
                       break;
                       
                   case 'user-left':
                       if (message.roomCode === this.roomCode && message.senderId !== this.userId) {
                           this.debug(`Utilisateur ${message.senderName} (${message.senderId}) a quitté la salle`);
                           
                           // Fermer la connexion peer avec cet utilisateur
                           if (this.peers.has(message.senderId)) {
                               const peer = this.peers.get(message.senderId);
                               peer.close();
                               this.peers.delete(message.senderId);
                           }
                           
                           // Fermer le canal de données
                           if (this.dataChannels.has(message.senderId)) {
                               const dataChannel = this.dataChannels.get(message.senderId);
                               if (dataChannel.readyState !== 'closed') {
                                   dataChannel.close();
                               }
                               this.dataChannels.delete(message.senderId);
                           }
                           
                           // Arrêter le flux distant
                           if (this.remoteStreams.has(message.senderId)) {
                               const remoteStream = this.remoteStreams.get(message.senderId);
                               remoteStream.getTracks().forEach(track => track.stop());
                               this.remoteStreams.delete(message.senderId);
                           }
                           
                           // Supprimer l'élément vidéo
                           const videoBox = document.getElementById(`video-box-${message.senderId}`);
                           if (videoBox) {
                               videoBox.remove();
                           }
                           
                           // Supprimer de la liste des participants
                           this.participants.delete(message.senderId);
                           
                           // Mettre à jour la liste des participants
                           this.updateParticipantsList();
                           
                           // Mettre à jour la grille vidéo
                           this.updateVideoGrid();
                           
                           // Afficher un message
                           this.displayChatMessage('system', 'Système', `${message.senderName} a quitté la salle`, false);
                       }
                       break;
                       
                   case 'room-participants':
                       if (message.roomCode === this.roomCode) {
                           this.debug(`Liste des participants reçue: ${JSON.stringify(message.participants)}`);
                           
                           // Mettre à jour la liste des participants
                           message.participants.forEach(participant => {
                               if (participant.id !== this.userId) {
                                   this.participants.set(participant.id, {
                                       id: participant.id,
                                       name: participant.name,
                                       connected: participant.connected || false
                                   });
                               }
                           });
                           
                           // Mettre à jour l'interface
                           this.updateParticipantsList();
                       }
                       break;
               }
           } catch (error) {
               this.debug(`Erreur lors du traitement du message: ${error.message}`, 'error');
           }
       }

       async createOfferForPeer(remotePeerId) {
           this.debug(`Création d'une offre pour ${remotePeerId}`);
           
           try {
               // Vérifier que la connexion peer existe
               if (!this.peers.has(remotePeerId)) {
                   this.debug(`Aucune connexion peer pour ${remotePeerId}`, 'error');
                   return;
               }
               
               const peerConnection = this.peers.get(remotePeerId);
               
               // Créer une offre avec des paramètres optimaux
               const offerOptions = {
                   offerToReceiveAudio: true,
                   offerToReceiveVideo: true
               };
               
               const offer = await peerConnection.createOffer(offerOptions);
               
               // Définir la description locale
               await peerConnection.setLocalDescription(offer);
               
               // Attendre que la collecte ICE soit suffisamment avancée
               await this.waitForSomeIceCandidates(remotePeerId);
               
               // Envoyer l'offre avec des informations supplémentaires
               this.sendSignalingMessage({
                   type: 'offer',
                   offer: peerConnection.localDescription,
                   roomCode: this.roomCode,
                   senderName: this.userName,
                   senderId: this.userId,
                   targetId: remotePeerId
               });
               
               this.debug(`Offre envoyée à ${remotePeerId}`);
           } catch (error) {
               this.debug(`Erreur lors de la création de l'offre pour ${remotePeerId}: ${error.message}`, 'error');
           }
       }

       async handleOffer(message) {
           this.debug(`Traitement de l'offre reçue de ${message.senderId}`);
           
           try {
               // Vérifier que la connexion peer existe
               if (!this.peers.has(message.senderId)) {
                   this.debug(`Aucune connexion peer pour ${message.senderId}, création...`);
                   this.setupPeerConnection(message.senderId);
               }
               
               const peerConnection = this.peers.get(message.senderId);
               
               // Ajouter les pistes média locales si ce n'est pas déjà fait
               if (this.localStream) {
                   const senders = peerConnection.getSenders();
                   if (senders.length === 0) {
                       this.localStream.getTracks().forEach(track => {
                           peerConnection.addTrack(track, this.localStream);
                       });
                   }
               }
               
               // Définir la description distante
               await peerConnection.setRemoteDescription(new RTCSessionDescription(message.offer));
               
               // Créer une réponse
               const answer = await peerConnection.createAnswer();
               
               // Définir la description locale
               await peerConnection.setLocalDescription(answer);
               
               // Attendre que la collecte ICE soit suffisamment avancée
               await this.waitForSomeIceCandidates(message.senderId);
               
               // Envoyer la réponse
               this.sendSignalingMessage({
                   type: 'answer',
                   answer: peerConnection.localDescription,
                   roomCode: this.roomCode,
                   senderName: this.userName,
                   senderId: this.userId,
                   targetId: message.senderId
               });
               
               this.debug(`Réponse envoyée à ${message.senderId}`);
           } catch (error) {
               this.debug(`Erreur lors du traitement de l'offre de ${message.senderId}: ${error.message}`, 'error');
           }
       }

       async handleAnswer(message) {
           this.debug(`Traitement de la réponse reçue de ${message.senderId}`);
           
           try {
               // Vérifier que la connexion peer existe
               if (!this.peers.has(message.senderId)) {
                   this.debug(`Aucune connexion peer pour ${message.senderId}`, 'error');
                   return;
               }
               
               const peerConnection = this.peers.get(message.senderId);
               
               // Vérifier l'état de signalisation
               if (peerConnection.signalingState === 'have-local-offer') {
                   // Définir la description distante
                   await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                   this.debug(`Réponse de ${message.senderId} traitée avec succès`);
                   
                   // Traiter les candidats ICE en attente
                   if (this.pendingIceCandidates.has(message.senderId)) {
                       const candidates = this.pendingIceCandidates.get(message.senderId);
                       this.debug(`Traitement de ${candidates.length} candidats ICE en attente pour ${message.senderId}`);
                       
                       for (const candidate of candidates) {
                           try {
                               await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                           } catch (error) {
                               this.debug(`Erreur lors de l'ajout d'un candidat ICE en attente: ${error.message}`, 'error');
                           }
                       }
                       
                       this.pendingIceCandidates.delete(message.senderId);
                   }
               } else {
                   this.debug(`État de signalisation incorrect pour ${message.senderId}: ${peerConnection.signalingState}`, 'error');
               }
           } catch (error) {
               this.debug(`Erreur lors du traitement de la réponse de ${message.senderId}: ${error.message}`, 'error');
           }
       }

       async handleIceCandidate(message) {
           if (!message.candidate) {
               this.debug('Candidat ICE null reçu, ignoré');
               return;
           }
           
           this.debug(`Traitement du candidat ICE de ${message.senderId}: ${JSON.stringify(message.candidate)}`);
           
           try {
               // Vérifier que la connexion peer existe
               if (!this.peers.has(message.senderId)) {
                   this.debug(`Aucune connexion peer pour ${message.senderId}`, 'error');
                   return;
               }
               
               const peerConnection = this.peers.get(message.senderId);
               
               // Si la description distante n'est pas encore définie, mettre le candidat en attente
               if (!peerConnection.remoteDescription) {
                   this.debug(`remoteDescription non définie pour ${message.senderId}, mise en attente du candidat ICE`);
                   
                   if (!this.pendingIceCandidates.has(message.senderId)) {
                       this.pendingIceCandidates.set(message.senderId, []);
                   }
                   
                   this.pendingIceCandidates.get(message.senderId).push(message.candidate);
                   return;
               }
               
               // Ajouter le candidat ICE
               await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
               this.debug(`Candidat ICE ajouté avec succès pour ${message.senderId}`);
           } catch (error) {
               this.debug(`Erreur lors de l'ajout du candidat ICE de ${message.senderId}: ${error.message}`, 'error');
           }
       }

       // Fonctions de gestion du chat
       toggleChat(forceState) {
           const newState = forceState !== undefined ? forceState : !this.isChatOpen;
           
           if (newState) {
               this.elements.chatContainer.classList.add('active');
               this.elements.chatToggle.style.display = 'none';
               this.isChatOpen = true;
               
               // Réinitialiser le compteur de messages non lus
               this.unreadMessages = 0;
               this.elements.chatNotification.textContent = '0';
               this.elements.chatNotification.style.display = 'none';
               
               // Focus sur l'input
               this.elements.chatInput.focus();
           } else {
               this.elements.chatContainer.classList.remove('active');
               this.elements.chatToggle.style.display = 'flex';
               this.isChatOpen = false;
           }
       }
       
       sendChatMessage() {
           const messageText = this.elements.chatInput.value.trim();
           
           if (!messageText) return;
           
           this.debug(`Envoi du message chat: ${messageText}`);
           
           // Afficher le message dans la fenêtre de chat
           this.displayChatMessage(this.userId, this.userName, messageText, true);
           
           // Envoyer le message à tous les participants
           const chatMessage = {
               type: 'chat-message',
               senderId: this.userId,
               senderName: this.userName,
               message: messageText,
               timestamp: Date.now()
           };
           
           // Envoyer via tous les canaux de données
           this.dataChannels.forEach((dataChannel, peerId) => {
               if (dataChannel.readyState === 'open') {
                   try {
                       dataChannel.send(JSON.stringify(chatMessage));
                   } catch (error) {
                       this.debug(`Erreur lors de l'envoi du message à ${peerId}: ${error.message}`, 'error');
                   }
               }
           });
           
           // Vider l'input
           this.elements.chatInput.value = '';
       }
       
       displayChatMessage(senderId, senderName, messageText, isSent) {
           // Créer l'élément de message
           const messageElem = document.createElement('div');
           messageElem.className = `chat-message ${isSent ? 'sent' : 'received'}`;
           
           // Si c'est un message système, appliquer un style différent
           if (senderId === 'system') {
               messageElem.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
               messageElem.style.color = 'var(--text-color)';
               messageElem.style.fontStyle = 'italic';
               messageElem.style.alignSelf = 'center';
           } else {
               // Ajouter le nom de l'expéditeur si ce n'est pas un message envoyé par l'utilisateur
               if (!isSent) {
                   const senderElem = document.createElement('div');
                   senderElem.className = 'message-sender';
                   senderElem.textContent = senderName;
                   messageElem.appendChild(senderElem);
               }
           }
           
           // Ajouter le contenu du message
           const contentElem = document.createElement('div');
           contentElem.textContent = messageText;
           messageElem.appendChild(contentElem);
           
           // Ajouter à la fenêtre de chat
           this.elements.chatMessages.appendChild(messageElem);
           
           // Scroll vers le bas
           this.elements.chatMessages.scrollTop = this.elements.chatMessages.scrollHeight;
           
           // Si le chat n'est pas ouvert, incrémenter le compteur de messages non lus
           if (!this.isChatOpen && !isSent) {
               this.unreadMessages++;
               this.elements.chatNotification.textContent = this.unreadMessages;
               this.elements.chatNotification.style.display = 'flex';
           }
       }

       toggleAudio() {
           if (this.localStream) {
               const audioTracks = this.localStream.getAudioTracks();
               if (audioTracks.length > 0) {
                   const audioTrack = audioTracks[0];
                   audioTrack.enabled = !audioTrack.enabled;
                   this.isAudioMuted = !audioTrack.enabled;
                   
                   this.elements.muteBtn.classList.toggle('muted', this.isAudioMuted);
                   this.elements.muteBtn.textContent = this.isAudioMuted ? '🔇' : '🎤';
                   this.elements.muteBtn.title = this.isAudioMuted ? 'Activer le micro' : 'Couper le micro';
                   
                   this.debug(`Microphone ${this.isAudioMuted ? 'désactivé' : 'activé'}`);
               }
           }
       }

       toggleVideo() {
           if (this.localStream) {
               const videoTracks = this.localStream.getVideoTracks();
               if (videoTracks.length > 0) {
                   const videoTrack = videoTracks[0];
                   videoTrack.enabled = !videoTrack.enabled;
                   this.isVideoMuted = !videoTrack.enabled;
                   
                   this.elements.videoBtn.classList.toggle('disabled', this.isVideoMuted);
                   this.elements.videoBtn.textContent = this.isVideoMuted ? '📷' : '📹';
                   this.elements.videoBtn.title = this.isVideoMuted ? 'Activer la caméra' : 'Couper la caméra';
                   
                   this.debug(`Caméra ${this.isVideoMuted ? 'désactivée' : 'activée'}`);
               }
           }
       }

       async leaveRoom() {
           this.debug('Quitter la salle');
           
           // Informer les autres participants que l'utilisateur quitte la salle
           if (this.socket && this.socket.readyState === WebSocket.OPEN && this.roomCode) {
               this.sendSignalingMessage({
                   type: 'user-left',
                   roomCode: this.roomCode
               });
           }
           
           // Mettre à jour le statut de la salle
           if (this.roomCode) {
               try {
                   const response = await fetch(`${this.apiEndpoint}/leave_room.php`, {
                       method: 'POST',
                       headers: {
                           'Content-Type': 'application/json'
                       },
                       body: JSON.stringify({ roomCode: this.roomCode })
                   });
                   
                   if (!response.ok) {
                       this.debug(`Erreur HTTP lors de la sortie de la salle: ${response.status}`, 'warn');
                   }
               } catch (error) {
                   this.debug(`Erreur lors de la sortie de la salle: ${error.message}`, 'error');
               }
           }

           // Nettoyer les flux
           if (this.localStream) {
               this.debug('Arrêt des pistes média locales');
               this.localStream.getTracks().forEach(track => track.stop());
               this.localStream = null;
           }
           
           // Fermer toutes les connexions peer
           this.peers.forEach((peer, peerId) => {
               this.debug(`Fermeture de la connexion peer avec ${peerId}`);
               peer.close();
           });
           this.peers.clear();
           
           // Fermer tous les canaux de données
           this.dataChannels.forEach((dataChannel, peerId) => {
               if (dataChannel.readyState !== 'closed') {
                   this.debug(`Fermeture du canal de données avec ${peerId}`);
                   dataChannel.close();
               }
           });
           this.dataChannels.clear();
           
           // Arrêter tous les flux distants
           this.remoteStreams.forEach((stream, peerId) => {
               stream.getTracks().forEach(track => track.stop());
           });
           this.remoteStreams.clear();
           
           // Vider la liste des participants
           this.participants.clear();
           
           // Vider le conteneur vidéo
           this.elements.videoContainer.innerHTML = '';
           
           // Fermer le chat
           this.toggleChat(false);
           this.elements.chatMessages.innerHTML = '';
           this.unreadMessages = 0;
           this.elements.chatNotification.style.display = 'none';
           this.elements.chatToggle.classList.remove('active');
           
           // Réinitialiser l'interface
           this.elements.setupSection.style.display = 'block';
           this.elements.roomList.style.display = 'block';
           this.elements.connectionInfo.style.display = 'none';
           this.elements.connectionStatus.style.display = 'none';
           this.elements.videoContainer.classList.remove('active');
           this.elements.callControls.classList.remove('active');
           this.elements.participantsContainer.style.display = 'none';
           this.elements.localVideoMini.style.display = 'none';
           
           this.elements.localVideo.srcObject = null;
           
           this.updateStatus('Vous avez quitté la salle', 'info');
           
           // Réinitialiser les variables
           this.roomCode = null;
           this.isInitiator = false;
           this.processedMessages.clear();
           this.pendingIceCandidates.clear();
           
           // Recharger la liste des salles
           this.loadUserRooms();
       }

       updateStatus(message, type = 'info') {
           this.debug(`Mise à jour du statut: ${message} (${type})`);
           this.elements.statusMessage.textContent = message;
           this.elements.statusMessage.className = `status-message ${type}`;
           this.elements.statusMessage.style.display = 'block';
           
           setTimeout(() => {
               this.elements.statusMessage.style.display = 'none';
           }, 5000);
       }
       
       showMessage(element, message, type = 'info') {
           element.textContent = message;
           element.className = `status-message ${type}`;
           element.style.display = 'block';
           
           setTimeout(() => {
               element.style.display = 'none';
           }, 5000);
       }
    }

    // Initialiser l'application
    document.addEventListener('DOMContentLoaded', () => {
       window.videoCallApp = new VideoCallPlatform();
    });

    // Gestion du thème sombre/clair
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.classList.add('dark');
    }
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
        if (event.matches) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    });
    </script>
</body>
</html>